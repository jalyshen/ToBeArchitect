# AQS 为什么要使用双向链表



### 1. 双向链表的特点

双向链表的特点是它有两个指针，一个指针指向前置节点，一个指针指向后继节点。所以，双向链表可以实现时间复杂度为 $O(1)$ 的前驱节点查找操作。

双向链表在插入、删除操作的时候，也要比单向链表更简单、高效。

### 2. AQS使用双向链表的原因分析

正因为双向链表有上述的优点，AQS从以下三个方面考虑使用它：

#### 2.1 避免线程竞争

没有竞争到锁的线程加入到阻塞队列，并且阻塞等待的前提是：当前线程所在的节点的前置节点是正常状态。 

这样设计是为了避免链表中存在异常线程导致无法唤醒后续线程的问题。

所以线程阻塞之前需要判断前置节点的状态，如果没有指针指向前置节点，就需要从head节点开始遍历，性能低下。

![1](.\images\AQS_dLinked\1.png)

#### 2.2 避免锁唤醒操作与链表遍历操作发送竞争

在 Lock 接口里，有一个 lockInterruptily() 方法，这个方法表示处于所阻塞的线程允许被中断。也就是说，没有竞争到锁的线程加入到同步队列等待以后，是允许外部线程通过 interrupt() 方法触发唤醒并中断的。

这个时候，被中断的线程状态会修改成 CANCELLED。

被标记为 CANCELLED 状态的线程，是不需要去竞争锁的，但是它依然存在于双向链表里。

![2](.\images\AQS_dLinked\2.png)

这意味着在后续的锁竞争中，需要把这个节点从链表中移除，否则会导致锁阻塞的线程无法被正常唤醒。

在这种情况下，如果是单向链表，就需要从 Head 节点开始往下逐个遍历，找到并移除异常状态节点，但是时间复杂度就是 $O(n)$，效率非常低下，还会导致锁唤醒的操作和遍历操作之间的竞争。

#### 2.3 快速判断是否头节点，有利于公平锁下的竞争

为了避免线程阻塞和唤醒的开销，所以刚加入到链表的线程，首先会通过自旋的方式尝试去竞争锁。

但是实际上按公平锁的设计，只有头节点的下一个节点才有必要去竞争锁，后续的节点竞争锁的意义不大，否则就会造成羊群效应，也就是大量的线程在阻塞之前尝试去竞争锁带来的比较大的性能开销。

所以为了避免这个问题，加入到链表中的节点在尝试竞争所之前，需要判断前置节点是不是头节点。如果不是头节点，就没必要再去触发锁竞争的动作。

![3](.\images\AQS_dLinked\3.jpg)

所以这里会涉及到前置节点的查找。如果是单向链表，那么这个功能的实现就会非常复杂了。