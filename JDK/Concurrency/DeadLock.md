# 死锁

原文：https://blog.csdn.net/qq_42411214/article/details/105115010



## 死锁的概念

### 死锁是什么

死锁是指**两个或两个以上的进程或者线程**在执行过程中，由于竞争资源或者由于**彼此通信**而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或者系统产生了死锁，这些永远在相互等待的进程成为死锁进程。这是操作系统层面的一个错误，是进程死锁的简称，最早在1965年由 Dijkstra 在研究银行家算法时提出来的，它是计算机操作系统乃至整个并发程序设计领域最佳处理的问题之一。

事实上，计算机世界有很多事情需要多线程方式去解决，因为这样才能最大程度上利用资源，才能体现出计算的高效。但是，实际上来说，计算机系统中有很多一次只能由一个进程使用资源的情况，例如打印机，同一个时间内只能有一个进程控制它。在多通道程序设计环境中，若干进程往往要共享这类资源，而且一个进程所需要的资源还很有可能不止一个。因此，就会出现若干进程竞争有限资源，又推进顺序不当，从而构成无限循环等待的局面。这种状态为“**死锁**”。简单一点描述，**死锁是指多个进程循环等待它方占有的资源而无限期地僵持下去地局面**。很显然，如果没有外力地作用，那么死锁涉及到地各个进程都将永远处于封锁状态。

### 死锁发生的原因

* 产生死锁原因

  * 竞争不可剥夺性资源
  * 进程间顺序推进非法

* 死锁产生地四个必要条件

  * **互斥条件**：当资源被一个线程使用（占用）时，别的线程不能使用
  * **不可剥夺抢占**：资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放
  * **循环等待/环路等待**：即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样形成一个等待环路
  * **请求和保持**：即当资源请求者在请求其他的资源的同时保持对原有资源的占有

* 竞争资源引起进程死锁

  当系统中供多个进程共享的资源（如打印机、公用队列等），其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。

  1. 可剥夺资源和不可剥夺资源

     系统中的资源可以分为两类：

     一类是可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或者系统剥夺。例如，优先权高的进程可以剥夺优先权低的进程的处理机。又如，内存区可由存储器管理程序，把一个进程从一个存储区域移到另一个存储区域，此即剥夺了该进程原来占有的存储区，甚至可以将一个进程从内存调到外存上。可见，CPU和主存均属于可剥夺性资源。

     另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行回收，只能在进程用完后自行释放，如磁带机、打印机等。

  2. 竞争不可剥夺资源

     在系统中所配置的不可剥夺资源，由于它们的数量不能满足诸进程运行的需要，会使进程在运行过程中，因争夺这些资源而陷于僵局。例如，系统中只有一台打印机R1和一台磁带机R2，可供进程P1和P2共享。假定P1已经占用了打印机R1，P2占用磁带机R2，若P2继续要求打印机R1，P2将阻塞；P1若又要求磁带机，P1将阻塞。于是在P1和P2之间形成了僵局，两个进程都在等待对方释放自己所需要的资源，但是它们又都因不能继续获得自己所需要得资源而不能继续推进，从而也不能释放自己所占用得资源，以致进入死锁的状态。

  3. 竞争临时资源

     上面说的打印机资源属于可顺序重复使用型资源，称为永久资源。还有一种所谓的临时资源，这是指由一个进程产生，被另一个进程使用，短时间后变无用的资源，故称为消耗性资源，如硬件中断、信号、消息、缓冲区内的消息等，它也可能引起死锁。

* 进程推进顺序不当引起死锁

  由于进程在运行中具有异步性特征，这可能使P1和P2两个进程按下述两种顺序向前推进。

## 处理死锁的基本方法

### 预防死锁

#### 通过破坏死锁的四个必要条件之一来预防死锁

1. 破坏请求和保持条件：静态资源分配法

   思想：资源调度时，若资源全满足则调度，否则等待

   缺点：

   	* 资源浪费
   	* 进程延迟运行
   	* 降低并发性

2. 破坏不可剥夺条件

   思想：进程资源申请不到，则释放已拥有资源

   缺点：

   	* 保持放弃资源时现场及现场的回复
   	* 可能出现反复申请释放资源而被无限延迟的现象

   *例子：哲学家就餐问题，体现预防死锁中破坏请求和保持，破坏不可剥夺条件。*

3. 破坏环路条件：有序资源分配法

   思想：资源编号，进程以递增的顺序申请资源

   缺点：

   	* 资源难以确定
   	* 后用的资源先申请，资源利用率低
   	* 限制编程的独立性

结论：

预防死锁通过破坏死锁的四个必要条件，排除发生死锁的可能性，但都会导致低效的资源利用率和低效的进程执行。

### 死锁避免

**不破坏死锁产生的四个必要条件，在资源的动态分配中，防止进程进入可能发生死锁的不安全状态。**死锁避免它允许三个必要条件，但通过明智的选择保证不会到达锁点，因此避免比预防允许更多的并发。

**思想**：系统进行资源分配应先计算此次资源分配后的状态安全性，若此次状态分配是安全的则进行资源分配，否则进行资源等待。

**避免死锁的算法**：银行家算法

最有代表性的算法是Dijkstra E.W 于1968年提出的银行家算法：

银行家算法是避免死锁的一种重要方法，防止死锁的机构只能确保上述四个条件之一不出现，则系统就不会发生死锁。通过这个算法可以用来解决生活中的实际问题，如银行贷款等。

### 死锁检测和解除

**允许系统出现死锁，但是系统具有检测死锁的的机制，在检测出死锁后系统将采取措补救措施。**

**先检测**：这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。检测方法包括定时检测、效率低时检测、进程等待时检测等。
**然后解除死锁**：采取适当措施，从系统中将已发生的死锁清除掉。
这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。*常用的实施方法是撤销或挂起一些进程*，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。

如果我们在死锁检查时发现了死锁情况，那么就要努力消除死锁，使系统从死锁状态中恢复过来。消除死锁的几种方式：

1. 最简单、最常用的方法就是**进行系统的重新启动**，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程；

2. **撤消进程，剥夺资源**。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素；

3. **进程回退策略**，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的。
   - 发现死锁后的处理方法
     **进程撤销、资源剥夺**
4. **进程撤销**：强制性的系统中撤销线程，以解除死锁的局面。
5. **资源剥夺**：将某个进程挂起，其目的是从占用资源的进程中重新拿到资源