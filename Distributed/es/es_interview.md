# Elastic Search 面试题

原文：https://www.cnblogs.com/heqiyoujing/p/11146178.html



### 1 为什么要使用 Elastic Search

因为在商城中的数据，将来会非常多，所以采用以往的模糊查询，模糊查询前置配置，会放弃索引，导致商品查询是全表扫面，在百万级别的数据库中，效率非常低下，而使用ES做一个全文索引，将经常查询的商品的某些字段，比如说商品名，描述、价格还有id这些字段放入我们索引库里，可以提高查询速度。

### 2 Elastic Search 是如何实现 Master 选举的

Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；
对所有可以成为master的节点（node.master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。
如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。
补充：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能。

#### 3 Elastic Search中的节点（如共20个），其中的10个选了一个master，另10个选了另一个master，如何办？

当集群master候选数量不小于3时，可以通过设置**最少投票通过数量**超过所有候选节点一半以上来解决脑裂问题；

当候选数量为2时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂。

### 4 详细描述 Elastic Search 索引文档的过程

协调节点默认**使用文档ID参与计算**（也支持通过Routing），以便为路由提供合适的分片。

​        shared= hash(document_id) % (num_of_primary_shards)

当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory Buffer，然后定时（默认是每隔1秒）写入到 Filesystem Cache，这个从 Memory Buffer 到 Filesystem Cache 的过程叫做 **refresh**；

当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失，**ES是通过 translog 的机制来保证数据的可靠性的**。其实现机制是接收到请求后，同时也写入到  translog 中，当 Filesystem cache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做**flush**；

在flush过程中，内存中的缓冲被清除，内容被写入一个新段（segment），段的 fsync 将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的translog

flush触发的时机是定时触发（默认是30分钟）或者 translog 变得太大（默认是512m）时。

### 5 Elastic Search 更新和删除文档的过程

删除和更新都是写操作，但是 Elastic Search 中的文档是不可变的，因此不能被删除或者更改。

磁盘上的每个段都有一个相应的 .del 文件。当删除请求发送后，文档并没有真的被删除，而是在 .del 文件中标记为删除。该文档依然能够匹配查询，但是会在结果中被过滤掉。当段合并时，在 .del 文件中被标记为删除的文档将不会被写入新段。

在新的文档被删除时，Elastic Search 会为该文档指定一个版本号，当执行更新时，旧版本的文档在 .del 文件中被标记为删除，新版本的文档被索引到一个新段。旧版的文档依然能匹配查询，但是会在结果中被过滤掉。

### 6 Elastic Search 搜索的过程

搜索的执行分成了两个阶段，称之为 Query Then Fetch。

Query阶段：

在开始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副分片）。每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在搜索的时候，是会查询 Filesystem Cache 的，但是有部分数据还在 Memory Buffer，所以搜索时近实时的

每个分片返回各自优先队列中，所有文档的ID和排序值给协调节点，它合并这些值到自己的优先队列中来，产生一个全局排序后的结果列表。

Fetch 阶段：

接下来就是取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个GET请求。每个分片加载并丰富文档。如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。

补充：

Query Then Fetch 的搜索类型在文档相关性打分的时候参考的损失本分片的数据，这样在文档数量较少的时候可能不够准确。DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document Frequency，这个评分更准确，但是性能会变差。

### 7 Elastic Search 对于大量数据（上亿量级）的聚合如何实现？

Elastic Search 提供的首个近似聚合时 cardinatily 度量。它提供一个字段的基数，即该字段的distinct 或者 unique 值的树木。它是基于 HLL（Hyper Log Log） 算法的。HLL 会先对输入做哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：精度可配置，用来控制内存的使用（更精确= 更多内存）；小的数据集精度是非常高的；可通过配置参数，来设置去重需要的固定内存使用量。无论数千亿的唯一值，内存使用量只与配置的精度相关。

### 8 高并发下，Elatic Search如何保证读写一致性

可以通过版本号使用了关锁来控制并发，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突。

对于写操作：

一致性级别支持 quorum/ one / all，默认是 quorum （意义：法定人数），即：只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。

one：就是有一个分片（节点）可用就可以写入；

all：必须所有分片（节点）可用才可以写入；

对于读操作：

可以设置 replication 为 sync（默认），这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片，确保文档是最新的版本。

### 9 Elastic Search 中的分片是什么？

在大多数环境中，每个节点都在单独的服务器（盒子）或虚拟机上运行的。

索引- 在 ES 中，索引是文档的集合

分片- 因为ES是一个分布式搜索引擎，所以索引通常被分割成分布在多个节点上 的被称为分片的元素。

### 10 ES中的集群、节点、索引、文档、类型是什么？

* **集群**：是一个或多个节点（服务器）的集合。它们共同保存整个数据，并提供跨所有节点的联合索引和搜索功能。集群由唯一名称标识，默认情况下是“elasticsearch”。因此名称很重要，因为如果节点设置为按名称加入集群，则该节点只能是集群的一部分
* **节点**：属于集群一部分的单个服务器。它存储数据并参与集群索引和搜索功能
* **索引**：类似关系数据库。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个或多个主分片，并且可以有0个或者多个副本分片。
* **文档**：类似于关系数据库中的一行。不同之处在于，索引中的每个文档可以具有不同的结构（字段），但是对于通用字段应该具备相同的数据类型。
* **类型**：是索引的逻辑类别/分区，其语义完全取决于用户。



### 11 ES的分析器

在ES中索引数据时，数据由为索引定义的 Analyzer 在内部进行转换。分析器是由一个 Tokenizer 和 0 个 或 多个 TokenFilter 组成的。编译器可以在一个或者多个 CharFilter 之前。分析模块允许在逻辑名称下注册分析器，然后可以在映射定义或者某些API中引用它们。