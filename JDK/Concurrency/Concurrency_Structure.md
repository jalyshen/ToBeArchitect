# Java并发结构

原文：http://ifeve.com/java-concurrency-constructs/

## 线程

​        线程是一个独立执行的调用序列，同一个进程的线程在同一时刻共享一些系统资源（比如文件句柄等），也能访问同一个进程所创建的对象资源（如内存资源）。

​        java.lang.Thread对象负责统计和控制这种行为。

​        每个程序都至少拥有一个线程-即作为Java虚拟机启动参数运行在主类main方法的线程。在JVM初始化过程中，也可能启动其他的后台线程。这种线程的数目和种类，因JVM的实现而异。然而，所有用户级线程，都是显式被构造并在主线程或者其他用户线程中被启动。

​        这里对Thread类中的主要方法和属性，以及一些使用注意事项作出总结。这些内容在书《Java Concurrency Constructs》上进行进一步的探讨阐述。



### 构造方法

​        Thread类中不同的构造方法接受如下参数的不同组合：

* 一个Runnable对象：这种情况，Thread.start方法将会调用对应Runnable对象的run方法。如果没有提供Runnable对象，那么就会立即得到一个Thread.run的默认实现
* 一个作为线程标识名的String字符串：该标识在跟踪和调试过程中会非常有用，除此别无他用
* 线程组(ThreadGroup)：用来放置新创建的线程，如果提供的ThreadGroup不允许被访问，那么就会抛出一个SecurityException

​        Thread类本身就已经实现了Runnable接口，因此，除了提供一个用于执行的Runnable对象作为构造参数的办法之外，也可以创建一个Thread的子类，通过重写其run方法来达到同样的效果。然而，**比较好的实践方式确实分开定一个Runnable对象并用来作为构造方法的参数。**将代码分散在不同的类中，使得开发人员不需纠结于Runnable和Thread对象中使用的同步方法或同步块之间的内部交互。更普遍的是，这种分隔使得对操作的本身与其运行的上下文有着独立的控制。更好的是，同一个Runnable对象可以同时用来初始化其他的线程，也可以用于构造一些轻量化的执行框架（Executors）。另外需要提到的是通过继承Thread类实现线程的方式有一个缺点：使得该类无法再继承其他的类。

​        Thread对象拥有一个守护（Daemon）标识属性，这个属性无法在构造方法中被赋值，但是可以在线程启动之前设置该属性（通过setDaemon方法）。当程序中所有的非守护线程都已经终止，调用setDaemon方法可能会导致虚拟机粗暴的终止线程并退出。isDaemon方法能够返回该属性的值。守护状态的作用非常有限，即使是后台线程在程序退出的时候也经常需要做一些清理工作。



### 启动线程

​        调用start方法会触发Thread实例以一个新的线程启动其run方法。新线程不会持有调用线程的任何同步锁。

​        当一个线程正常地运行结束，或者抛出某种未检测的异常（比如：运行时异常RunningException、错误ERROR或者其子类），线程就会终止。当线程终止之后，是不能被重新启动的。在同一个Thread上调用多次start方法会抛出InvalidThreadStateException异常。

​        如果线程已经启动但是还没有终止，那么调用isAlive方法就会返回true，即使线程由于某些原因处于阻塞（Blocked）状态，该方法依然返回True。如果线程已经被取消（cancelled），那么该方法在什么时候返回false，就因各JVM的实现差异了。没有方法可以得知一个处于非活跃状态的线程是否已经被启动过（即：线程在开始运行前和结束运行后都会被返回false，无法得知处于false的线程具体的状态）。另外，虽然一个线程能够得知同一个线程组的其他线程的标识，但是却无法得知自己是由哪个线程调用启动的。



### 优先级

​         JVM为了实现跨平台的特性，Java语言在线程调用与调度公平性上未作出任何的承诺，甚至都不会严格保证线程会被执行。但是Java线程却支持优先级的方法，这些方法会影响线程的调度。

​        每个线程都有一个优先级，分布在Thread.MIN_PRIORITY和Thread.MAX_PRIORITY之间（分别是1和10）。默认情况下，新创建的线程都拥有和创建它的线程相同的优先级。main方法所关联的初始化线程拥有一个默认的优先级，这个优先级是Thread.NORM_PRIORITY(5)。 可以通过getPriority方法获得线程的优先级，也可以通过setPriority方法来动态修改。**一个线程的最高优先级有其所在的线程组限定**。

​        当可运行的线程数超过了可用的CPU数目时，线程调度器更偏向于去执行那些拥有更高优先级的线程。具体的策略因平台而异。比如有些JVM实现总是选择当前优先级最高的线程去执行；有些JVM将Java中的10个优先级映射到系统所支持的最小范围的优先级上，因此，拥有不同的优先级的线程可能最终被同等对待；还有些JVM会使用老化策略（随着时间的增长，线程的优先级逐渐升高）动态调整线程优先级；另一些JVM的调度策略会确保低优先级的线程最终还是能够有机会运行。设置线程优先级可以影响在同一台机器上运行的程序之间的调度结果，但是这不是必须的。

​        线程优先级对语义和正确性没有任何的影响。特别是，优先级管理不能用来代替锁机制。优先级仅仅是用来表明哪些线程是重要紧急的，当存在很多线程在激烈进行CPU资源竞争的情况下，线程的优先级标识将会显得非常有用。比如：在ParticleApplet中将particle animation线程的优先级设置的比创建它们的applet线程低，在某些系统上能够提高对鼠标点击的响应，而且不会对其他功能造成影响。但是即使setPriority方法被定义为空实现，程序在设计上也应该保证能够正确执行（尽管可能会没有响应）。

​        下面这个表格列出了不同类型任务在线程优先级设定上的通常约定。在很多并发应用中，在任一指定的时间点上，只有相对较少的线程处于可执行的状态（另外的线程可能由于各种原因处于阻塞状态），在这种情况下，没有什么理由需要去管理线程的优先级。另外一些情况下，在线程优先级上的调整可能会对并发系统的调优起到一些作用。

| 范围 | 用途                                                        |
| ---- | ----------------------------------------------------------- |
| 10   | Crisis management (应急处理)                                |
| 7-9  | Interactive, event-driven（交互相关，事件驱动）             |
| 4-6  | IO-bound （IO限制类）                                       |
| 2-3  | Background Computation （后台计算）                         |
| 1    | Run only if nothing else can （尽在没有任何线程运行时运行） |



### 控制方法

​        只有很少几个方法可以用于跨线程交流。

* 每个线程都有一个相关的Boolean类型的中断标识。在线程 t 上调用 t.interrupt() 会将该线程的中断标识设置为true，除非线程 t 正处于 Object.wait(), Thread.sleep()，或者Thread.join()。这些情况下，interrupt()调用会导致 t 上的这些操作抛出 InterruptedException 异常，但是 t 的中断标识会被设置为false
* 任何一个线程的中断状态都可以通过调用 isInterrupted() 方法来得到。如果线程已经通过 interrupt() 方法被中断，这个方法将会返回 true
* 但是，如果调用了Thread.interrupted() 方法且中断标识还没有被重置，或者是线程处于wait，sleep，join过程中，调用 isInterrupted() 方法将会抛出 InterruptedException 异常。调用 t.join() 方法将会暂停执行调用线程，直到线程t执行完毕：当 t.isAlive() 方法返回false的时候调用 t.join() 将会直接返回(return)。另一个带参数毫秒(millisecond)的join方法在被调用时，如果线程没能够在指定的时间内完成，调用线程将重新得到控制权。因为isAlive方法的实现原理，所以在一个还没有启动的线程上调用join方法是没有任何意义的。同样的，试图在一个还没有创建的线程上调用join方法也是不明智的

​        起初，Thread类还支持一些控制方法：suspend,resume,stop以及destroy。这几个方法已经被声明为过期了。其中，destroy() 方法从来没有被实现，估计以后也不会。而通过使用等待/唤醒机制增加suspend和resume方法在安全性和可靠性的效果有所欠缺。

## 同步

## 监视器