# JVM内存溢出的 10 大场景

原文：https://blog.csdn.net/Vincent9847/article/details/117826943



​        JVM运行时首先需要类加载器（classLoader）加载所需类的字节码文件。加载完毕交由执行引擎执行，在执行过程中需要一段空间来存储数据（类比CPU与主存）。这段内存空间的分配和释放过程正是我们需要关心的运行时数据区。**内存溢出的情况就是从类加载器加载的时候开始出现的**，内存溢出分为两大类：***OutOfMemoryError*** 和 ***StackOverflowError***。以下举出10个内存溢出的情况，并通过实例代码的方式讲解了是如何出现内存溢出的。



## 1. JVM堆内存溢出

​        当出现 ***java.lang.OutOfMemoryError: Java heap space*** 异常时，就是**堆内存**溢出了。

​        所谓“**益出**”，就是内存设置（或者剩余）太小，不够装在新建的对象。

### 1.1 问题描述

​        设置 JVM 内存太小，对象所需内存太小，创建对象时分配空间，就会抛出这个异常。（流量/数据峰值，应用程序自身的处理存在一定的限额，比如一定数量的用户或一定数量的数据。而当用户数量或者数据量突然激增并超过预期的阈值时，那么就会峰值停止前正常运行的操作将停止并触发 ***java.lang.OutOfMemoryError:Java heap space*** 堆空间错误）

### 1.2 代码示例

​        // 代码忽略

​        编译上面代码，执行时，JVM参数设置为 ***-Xms20m -Xmx20m***

​        以上示例，如果一次请求只分配一次5m 的内存，请求量很少，垃圾回收正常，不会出现错误。但是一旦并发量上来，就会超出最大内存值，就会抛出内存溢出错误。

### 1.3 解决方法

​        首先，如果代码没有什么问题的情况下，可以适当调整 ***-Xms*** 和 ***-Xmx*** 这两个参数，使用**压力测试**来调整这两个参数的值，使之达到最优值。

​        其次，尽量避免大的对象的申请。像文件上传、大批量从数据库取数据，这都是需要避免的，尽量分块或者分批处理，有助于系统的正常稳定的执行。

​        最后，尽量提高一次请求的执行速度，垃圾回收越早越好，否则，大量的并发来了的时候，再来新的请求就无法分配内存了，容易造成系统的雪崩。

## 2 JVM堆内存泄漏

​        所谓“**泄漏**”，就是无用的对象占据了大量的内存空间，无法被回收。

### 2.1 问题描述

​        Java中的内存泄漏是一些对象不再被应用程序使用，但垃圾收集无法识别的情况。因此，这些未使用的对象仍然在 Java 堆中无限期的存在。不停的堆积，最终会触发 ***java.lang.OutOfMemoryError***。

### 2.2 示例代码

​        // 省略代码

​        当执行上面代码时，可能会期望它永远运行下去，不会出现任何问题。假设单纯的缓存解决方案只将底层映射扩展到 100000 个元素，而不是所有键都已经在 HashMap 中。然而事实上元素将继续被添加，因为 Key 类并没有重写它的 equals() 方法。

​        随着时间的推移，随着不断使用的泄漏代码，“缓存”的结果最终会消耗大量 Java 堆空间。当泄漏内存填充堆区域中的所有内存时，垃圾收集无法清理它，造成了 java.lang.OutOfMemoryError。

### 2.3 解决办法

​        相对来说，应对的解决方案比较简单：重写 equals 方法即可。

## 3 垃圾回收超时内存溢出

### 3.1 问题描述

​        当应用程序耗尽所有可用内存时，GC开销限制超过了错误，而 GC 多次为能清除它，这时就会引发 java.lang.OutOfMemoryError。当 JVM 花费大量的时间执行GC，而收效甚微，而一旦整个 GC 的过程超过限制，便会触发错误（默认的 JVM 配置 GC 的时间超过 98%，回收堆内存低于 2%）

### 3.2 示例代码

### 3.3 解决办法

​        要减少对象的生命周期，尽量能快速的进行垃圾回收。

## 4 Metaspace内存溢出

### 4.1 问题描述

​        元空间的溢出，系统会抛出 *java.lang.OutOfMemoryError: **Metaspace***。出现这个异常的问题的原因是：系统的代码非常多，或者引用的第三方包非常多，或者通过动态代码生成类加载等方法，导致元空间的内存占用大。

### 4.2 示例代码

​        // 省略代码

​        以上代码用循环动态生成 class 的方式来模拟元空间的内存溢出

### 4.3 解决办法

​        默认情况下，元空间的大小仅受本地内存限制。但是为了整机性能，尽量还是要对该项进行设置，以免造成征集的服务停机。

#### 4.3.1 优化参数设置，避免影响其他JVM进程

​        ***-XX:MetaspaceSize***，设置元空间的初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时 GC 会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过 ***MaxMetaspaceSize*** 时，适当提高该值。

​        ***-XX:MaxMetaspaceSize***，最大空间，**默认是没有限制的**。

​        除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：

​        ***-XX:MinMetaspaceFreeRatio***，在 GC 之后，最小的 Metaspace 剩余空间容量的百分比，减少为**分配空间**所导致的垃圾收集。

​        ***-XX:MaxMetaspaceFreeRatio***，在 GC 之后，最大的 Metaspace 剩余空间容量的百分比，减少为**释放空间**所导致的垃圾收集。

#### 4.3.2 慎用第三方包

​        对于第三方包，一定要慎重选择，不需要的包就去掉。这样有助于提高编译打包的速度，也有助于提高远程部署的速度。

#### 4.3.3 关注动态生成类的框架

​        对于使用大量动态生成类的框架，要做好压力测试，验证动态生成的类是否超出内存的需求，从而抛出内存溢出异常。

## 5 直接内存溢出

### 5.1 问题描述

​        **ByteBuffer** 中的 ***allocateDirect()*** 方法，很多 Java NIO 的框架（如Netty）都会把该方法封装到框架的某些方法中，使用不当，就会抛出 *java.lang.OutOfMemoryError: **Direct buffer memory*** 异常。

​        如果在直接或间接的使用了 ByteBuffer 的 ***allocateDirect()***，又不做 ***clear*** 时，就会出现类似的问题。

### 5.2 解决办法

​        如果经常有类似的操作，可以考虑设置参数： ***-XX:MaxDirectMemorySize***，并及时清理内存。

## 6 栈内存溢出

### 6.1 问题描述

​        **当一个线程执行一个 java 方法时，JVM 将创建一个新的栈帧并且把它 push 到栈顶**。此时新的栈帧就变成了当前栈帧，方法执行时，使用***栈帧来存储参数、局部变量、中间指令以及其他数据***。

​        当一个方法递归调用自己时，新的方法所产生的数据（也可以理解为新的栈帧）将会被 push 到栈顶；方法每次调用自己时，会拷贝一份当前方法的数据并 push 到栈中。因此，**递归的每层调用都需要创建一个新的栈帧**。这样的结果是，栈中越来越多的内存将随着递归调用而被消耗，如果递归调用自己一百万次，那么就会产生一百万个栈帧。这样就会造成栈的内存溢出。

### 6.2 解决办法

​        如果程序中确实有递归调用，出现栈溢出时，可以调高 ***-Xss*** 大小，就可以解决栈内存溢出的问题。递归调用防止形成死循环，否则就会出现栈内存溢出。

## 7 创建本地线程内存溢出

### 7.1 问题描述

​        **线程基本只占用 heap 以外的内存区域**，也就是这个错误说明，除了 heap 以外的区域，无法为线程分配一块内存区域了，这个要么是内存本身就不够，要么 heap 的空间设置的太大了，导致了剩余的内存不多了，而由于线程本身要占用内存，所以就不够用了。

### 7.2 解决办法

​        首先检查操作系统是否有线程数的限制，使用 shell 也无法创建线程，如果是这个问题，就需要调整系统的最大可支持的文件数。

​        日常开发中尽量保证线程最大数是可控制的，不要随意使用线程池。不能无限制的增长下去。

## 8 超出交换区内存溢出

### 8.1 问题描述

​        在Java应用启动过程中，可以通过 ***-Xmx*** 和其他类似的启动参数限制指定的所需的内存。而**当 JVM 所请求的总内存大于可用物理内存的情况下，操作系统开始将内容从内存转换为硬盘**。

​       一般来说，JVM 会抛出 ***Out of swap space*** 错误，代表应用程序向 JVM native heap 请求分配内存失败并且 native heap 也即将耗尽时，错误消息中包含分配失败的大小（以字节为单位）和请求失败的原因。

### 8.2 解决办法

​        首先，增加系统交换区大小，个人认为，如果使用了交换区，性能会大大降低，不建议采用这种方式，生产环境尽量避免最大内存超过系统的物理内存。

​        其次，去掉系统交换区，只使用系统的内存，保证应用的性能。

## 9 数组超限内存溢出

### 9.1 问题描述

​        有时候会碰到这种内存溢出的描述：***Requested array size exceeds VM limit***。一般来说，Java 应用程序所能分配数组最大大小是有限制的，只不过不同的平台限制有所不同。但通常在 ***1 到 21 亿 （int的最大值，$2^{31} - 1$）*** 个元素之间。 当 Requested array size exceeds VM limit 错误发生时，意味着应用程序试图分配大于 JVM 可以支持的数组。**JVM 在为数组分配内存之前，会执行特定平台的检查：分配的数据结构是否在此平台时可寻址的**。

### 9.2 示例代码

​        // 省略代码

​        以上代码就是数组超出了最大限制

### 9.3 解决办法

​        因此数组长度要在平台允许的长度范围之内。不过这个错误一般少见，主要是由于 Java 数组的索引使用的是 **int** 类型。Java中的最大正整数是 $2^{31} - 1 = 2147483647$ 。并且平台特定的限制可以非常接近这个数字。例如：一个环境上（64位的macOS，运行JDK8）可以初始化数组的长度高达 2,147,483,645 (Integer.MAX_VALUE - 2)。若是将数组的长度再增加 1 达到 integer。MAX_VALUE - 1，就会出现 OutOfMemoryError 异常。

## 10 系统杀死进程内存溢出

### 10.1 问题描述

​        描述这个问题之前，需要先了解一下操作系统的知识：操作系统是建立在进程的概念之上的，这些进程在内核中作业，其中有一个非常特殊的进程，称为“内存杀手（Out of momory killer）”。当内核检测到系统内存不足时，OOM Killer 被激活，检查当前谁占用了内存最多，然后将该进程杀掉。

​        一般 *Out of memory: Kill process or sacrifice child* 这个错误会在当可用虚拟内存（包括交换空间）消耗到让整个操作系统面临风险时，会被触发。这种情况下，OOM Killer 会选择“流氓进程”并杀死它。

### 10.2 解决办法

​        虽然增加交换空间的方式可以缓解 ***Java heap space*** 异常，还是建议最好的方案是升级系统内存，让 Java 应用有足够的内存可用。



## 11 总结

​        通过上述 10 种内存溢出的介绍，总结一下几点：

1. 慎重引入第三方 Jar包，**坚决去掉**没用的 Jar 包，提高编译的速度和减少系统的内存占用
2. 对于大的对象或者大量的内存申请，要进行优化，大的对象要分片处理，提高处理性能，缩短对像生命周期
3. 尽量固定线程的数量，保证线程占用的内存可控，同时需要大量线程时，要优化好操作系统的最大可打开的连接数（文件数）
4. 对于递归调用，要控制好递归层级，不能太多
5. 分配给栈的内存并不是越大越好，因为栈内存越大，线程越多，留给堆的空间就不多了，容易抛出OOM。JVM默认的参数配置一般情况下都不会有问题，即使有递归调用，

