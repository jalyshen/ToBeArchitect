# JVM 方法区的演变过程和内部结构

原文：https://www.toutiao.com/a7014084390775161376/?log_from=7dbc4486c600b_1633141394042



![1](./images/JVM_Structure/1.png)

## 一. 简介

​        创建对象时，内存分配简图（非常有用）

![2](./images/JVM_Structure/2.jpeg)

![3](./images/JVM_Structure/3.png)

​        《Java 虚拟机规范》中明确说明：***尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩***。

​        虽然，Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是，它却有一个别名，叫做“ ***Non-Heap （非堆）***”，目的应该是与 Java 堆区分开来。所以，方法区可以看作是一块**独立于** Java 堆的内存空间。

​        方法区与 Java堆一样，是**各个线程共享的内存区域**。方法区在JVM启动时就会被创建，并且它的实际物理内存空间是可以**不连续**的。关闭 JVM 就会释放这个区域的内存。

## 二. 永久代、元空间

​        《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 虚拟机中，就不存在“**永久代**”的概念。而对于 HotSpot 而言，在 JDK 7 及以前，习惯上把方法区的实现称为**永久代**，而从 JDK8 开始，使用**元空间**取代了永久代。

> 方法区是 Java 虚拟机规范中的概念，而永久代和元空间是 HotSpot 虚拟机对方法区的一种实现。通俗地说：如果把方法区比作接口，那么永久代和元空间就是这个接口的不同实现。



## 三.直接内存

​        永久代、元空间并不只是名字变了，内部结构也进行了调整。**永久代使用的是JVM的内存，而元空间使用的是本地的直接内存**。

​        直接内存并不是 JVM 运行时数据区的一部分，因此不会受到 Java堆的限制。但是它会受到本机总内存大小以及处理器寻址空间的限制，所以如果这部分内存也被频繁的使用，依然会导致 OOM 的错误出现。

## 四. 方法区的大小

​        方法区的大小是可以进行调整的，可以选择固定大小，也可以进行扩展。

### 4.1 JDK7 及以前

* --XX:Perm Size=N // 方法区（永久代）初始分配空间，默认是 20.75M
* --XX:MaxPermSize=N // 方法区（永久代）最大可分配空间。32位机器默认是64M，64位机器默认是 82M

### 4.2 JDK8 及以后

​        默认值依赖于具体的平台，如 Linux 、Unix、Windows等。以Windows为例：

* --XX:MetaspaceSize=N // 方法区（元空间）初始分配空间，如果未指定值，则元空间将根据运行时的应用程序需求动态地重新调整大小
* --XX:MaxMetaspaceSize=N // 方法区（元空间）最大可分配空间，默认值是 -1，即没有限制

​       与永久代很大的不同是：如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的**系统内存**。

​       方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，比如：加载大量的第三方jar，Tomcat部署的工程过多、大量动态生成反射类等，都会导致方法区（元空间）溢出，抛出内存溢出的错误：

* 永久代：OutOfMemoryError: PermGen space
* 元空间：OutOfMemoryError: Metaspace

### 4.3 jvisualvm

​        可以通过 JDK 自带的 jvisualvm 工具查看程序加载的类文件。例如：

```java
public class MethodAreaDemo1 {
    public static void main(String[] args) {
        System.out.println("start...");
        try {
            Thread.sleep(100000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("end...");
    }
}
```

​        运行程序，可以看到一个简单的程序就需要加载这么多的类文件：

![4](./images/JVM_Structure/4.png)

## 五. 高水位线

​        对于一个 64 位的服务器端 JVM 来说，***--XX:MetaspaceSize=21*** 就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。

​        新的高水位线的值取决于 GC 后释放了多少元空间：

* 如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高该值
* 如果释放空间过多，则适当降低该值

> 如果初始化的高水位线设置过低，高水位线调整情况会发生很多次（比较频繁发生）。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地 GC，建议将 --XX: MetaspaceSize 设置为一个相对较高的值

## 六. 内部结构

​        《深入理解 Java 虚拟机》书中对方法区存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。接下来一起看看它的内部结构：

![5](./images/JVM_Structure/5.png)

### 6.1 类型信息

​        对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：

1. 这个类型的完整有效名称（全名=包名.类名）
2. 这个类型直接分类的完整有效名（对于 interface 或是 java.lang.Object，都没有父类）
3. 这个类型的修饰符（public、abstract、final的某个子集）
4. 这个类型直接接口的一个有序列表

### 6.2 域 (Field) 信息

1. JVM 必须在方法区中保存类型的所有域（field，也称为属性）的相关信息以及域的**声明顺序**
2. 域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient的某个子集）

### 6.3 方法 (Method) 信息

​        JVM 必须保存所有方法的以下信息，同域信息一样包括**声明顺序**：

* 方法名称
* 方法的返回类型（或 void）
* 方法参数的数量和类型（按顺序）
* 方法的修饰符（public、private、protected、static、final、synchronized、native、abstract的一个子集）
* 方法的字节码（bytecodes）、操作数栈、局部变量表以及大小（abstract 和 native 方法除外）
* 异常表（abstract 和 natvie 方法除外）每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

### 6.4 non-final 的类信息

* 静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分
* 类变量被类的所有实例所共享，即使没有类实例也可以访问

​        通过下面例子来理解：

```java
public class MethodAreaDemo2 {
    public static void main(String[] args) {
        Order order = null;
        order.hello();
        System.out.println(order.count);
    }
}

class Order {
    public static int count = ;
    public static final int number = 2;
    
    public static void hello() {
        System.out.println("hello!");
    }
}
```

运行结果：

> hello!
>
> 1

打开一个终端，在 MethodAreaDemo2.class 所在的路径下输入：

```shell
javap -v -p MehtodAreaDemo2.class
```

得到：

![6](./images/JVM_Structure/6.png)

从上面看出，被声明为 final 的类变量的处理方式是不一样的，全局常量在编译的时候就被分配了。

### 6.5 运行时常量池

​        说到运行时常量池，先来了解一下什么是常量池表

#### 6.5.1 常量池表

​        一个有效的字节码文件中，除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息，那就是**常量池表（Constant Pool Table）**，里边存储着数量值、字符串值、类引用、字段引用和方法引用。

![7](./images/JVM_Structure/7.png)

#### 6.5.2 为什么字节码文件需要常量池

​        Java 源文件中的类、接口、编译后会产生一个字节码文件。而字节码文件需要数据支持，通常这种数据会很大，以至于不能直接存放到字节码中。换一种方式，可以将指向这些数据的**符号引用**存到字节码文件的常量池中，这样字节码只需要使用常量池就可以在运行时通过**动态链接**找到相应的数据并使用。

#### 6.5.3 运行时常量池

​        运行时常量池（Runtime Constant Pool）是方法区的一部分，类加载器加载字节码文件时，将常量池表加载进方法区的运行时常量池。运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能获取的方法或者字段引用。此时，不再是常量池中的符号地址了，这里换成了**真实**地址。

> 运行时常量池，相对于 Class 文件常量池的另一个重要特征：具备动态性，比如：String.intern()

## 七. 演进细节

​        所谓的演变，针对的是HotSpot 的虚拟机：

* **JDK 6 及之前**：**有**永久代，静态变量存放在永久代上
* **JDK7**：**有**永久代，但已经逐步“去永久代”，**字符串常量池、静态变量移除，保存在堆中**
* **JDK8 及以后**：**无**永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但**字符串常量池、静态变量仍在堆中**

### 7.1 演变示例图

* JDK 6- :

![8](./images/JVM_Structure/8.png)

* JDK 7

![9](./images/JVM_Structure/9.png)

* JDK 8+

![10](./images/JVM_Structure/10.png)

### 7.2 为什么要删除永久代换为元空间呢

1. 永久代使用的是 JVM 的内存，受 JVM 设置的内存大小的限制；元空间使用的是本地直接内存，它的最大可分配空间是系统可用内存的空间。因为元空间里存放的是**类的元数据**，所以随着内存空间的增大，能加载的类就更多了，相应的溢出的机率会大大减小
2. 在JDK8，合并 HotSpot 和 JRockit 的代码时，JRockit 从来没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了
3. 对永久代进行调优是很困难的

### 7.3 StringTable 为啥要调整

​       因为永久代的回收效率很低，在 Full GC 的时候才会触发。而 Full GC 是老年代的空间不足、永久代不足时才会触发。这就导致了 StringTable 回收效率不高。而开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。

### 7.4 垃圾回收

​       相对而言，垃圾收集行为在这个区域时比较少出现的，但并非数据进入方法区后就“永远存在”了。方法区的垃圾收集主要回收两部分内容：**常量池中废弃的常量** 和 **不再使用的类型**。

​       **方法区内常量池**中主要存放**字面量**和**符号引用**两大类常量：

* 字面量比较接近 Java 语言层次的常量概念，如文本字符串、被申明为final的常量值等
* 符号引用则属于编译原理方面的概念，包括类和接口的全限定名、字段的名称和描述符

​       HotSpot 虚拟机对常量池的回收策略时很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。

### 7.5 类型判断

​       判定一个常量是否“废弃”还是相对简单的，而要判断一个**类型**是否属于“不再被使用的类”的条件就比较苛刻了。需要**同时满足**以下三个条件：

* 该类**所有的实例**都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例
* 加载该类的**类加载器**已经被回收，这个条件除非是经过精心设计的可替换加载类的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的
* 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

​       Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许“，而并不是和对象一样，没用引用就必然会回收。