# Java的8种基本数据类型

原文：https://blog.csdn.net/e/article/details/107149316



## 一. 整数类型

| 类型            | 字节个数  | 取值范围              |
| --------------- | --------- | --------------------- |
| byte（字节）    | 1（8位）  | $-2^7 ～ 2^7-1$       |
| short（短整形） | 2（16位） | $-2^{15} ～ 2^{15}-1$ |
| int（整型）     | 4（32位） | $-2^{31} ～ 2^{31}-1$ |
| long（长整型）  | 8（64位） | $-2^{63} ～ 2^{63}-1$ |

## 二. 浮点类型

​        https://blog.csdn.net/softwater007/article/details/3330619

​        在计算机中表达实数有两种方式：

* **定点表示法** (fixed-point)：在现有的数字中间的**某个位置固定小数点**，整数部分和小数部分的表示与一个普通整数的表示法没有什么两样。例如：数字长度为4，小数点位于中间，那么可以表示 $10.28$，也可以表示 $00.01$。与这种方法性质类似的定点表示还有使用分数的形式。

  定点数的固定窗口形式，使得它既不能够表示非常大的数，又不能表示非常小的数，并且当除法发生时，大量的精度丢失。

* **浮点表示法** (floating-point)：浮点数**采用科学计数法**的形式来表示实数。例如：$123.456$ 表示成 $1.23456 \times 10^2$ 。相对于定点数的固定窗口（fixed window）的限制，它采用的是**浮动窗口**（sliding Window），因此可以表示较大精度范围的一个实数。

### 2.1 浮点类型

| 类型                     | 字节数    | 精度问题       |
| ------------------------ | --------- | -------------- |
| float（单精度浮点类型）  | 4（32位） | 保留8位小数点  |
| double（双精度浮点类型） | 8（64位） | 保留16位小数点 |

### 2.2 float 与 double 精度丢失问题

1. float 与 double 运算时，将 十进制 转为 二进制
2. 整数永远可以用二进制精确的表示，但小数不一定
3. 小数的二进制有时候不可能准确的，有时会无限算下去
4. 解决精度丢失问题，使用 BigDecimal 类解决。针对货币，不能使用float/double

### 2.3 浮点数的存储布局 (Storage Layout)

​        所谓的存储布局，就是一个浮点数在内存中如何表示。浮点数有 float 和 double，前者是 4 个字节，32位；后者是 8 个字节，64位。布局分别是：

|               | 符号位 | 指数部分     | 小数部分     | 偏移附加(bias) |
| ------------- | ------ | ------------ | ------------ | -------------- |
| 单精度 float  | 1[31]  | 8 [30 - 23]  | 23 [22 - 00] | 127            |
| 双精度 double | 1[63]  | 11 [62 - 52] | 52 [51 - 00] | 1023           |

> 说明：
>
> * 中括号内为位的编号范围
> * 外面的数为该部分所占有的位的数量
> * 偏移附加不属于位表示的内容，是一个常量，后面解释

* **符号位**：只有一位，0 - 表示正数；1 - 表示负数
* **指数部分**：用指数部分的值（8位/11位，unsigned）的值 **减去** 偏移附加，得到该数实际的指数。例如：值为200，实际指数为 73 = 200 - 127；对于双精度的double来说，则是减去 1023
* **尾数**：对于一个科学计数法来讲，形式像这样的 L.MxBE，那么这个 **L.M** 就是所谓的尾数（mantisa）。它由一个起始位和一个小数部分组成。举个例子：5 可以用科学计数法表示成不同的形式： $5 \times 10^0, 0.5 \times 10^1, 50 \times 10^{-1}$



## 三.  布尔类型

1. boolean 的值只有两个： true 和 false

2. 在8种简单类型中，除了boolean，都可以自动转换成其它类型

   * 自动转换（ 小 -> 大）: byte -> int , char -> int

   * 强制转换（大 -> 小）: int -> char , double -> long

## 四. 面试题

1. short s1 = 1; s1 = s1 + 1;  有何错？ short s1 = 1; s1 += 1; 有何错？

   答：

   * 第一个表达式有错， s1 + 1 中 1 是 int ，右边的结果是 int，但是 s1 是 short，需要强制类型转换 s1 = (short) (s1 + 1)
   * 第二个表达式没有错误，因为 += 这种扩展赋值运算符会自动转换数据类型

2. char 类型变量能不能存储一个中文的汉字，为什么？

   答：

   ​        char 是 2 个字节16位，所以可以使用 unicode 编码表示，只要是在 unicode 编码中文范围的汉字都可以存储 4E00-9FA5，但是也有特殊的情况，比如生僻字不能存储。

3. Integer 和 int 的区别

   答：

   ​        int 是基本数据类型，只能用于算术运算、位运算；Integer 是引用数据类型，类提供很多方法去便捷操作一些 int 值。比如： 十进制数转换二进制的方法

4. 能否在不进行强制转换的情况下将一个 double 值赋给 long 类型的变量？

   答：

   ​        不可以。虽然 double 和 long 都是 8 个字节（64位），但是底层的存储结构不一样。double 表示的范围 > long表示的范围。所以需要强制转换

5. java 中 3 * 0.1 == 0.3 将会返回什么？ true 还是 false？

   答：

   ​        java 中 float 和 double 在做运算时都会丢失精度，所以这个表达式的值是 **false**

6. java 中 float f = 3.4; 是否正确？

   答：

   ​        3.4 默认是 double 类型，若强制将 3.4 赋给 float，需要进行强制转换，也有其它解决方法：

   * 方式一：3.4后面添加 f 或者 F： float f = 3.4F;
   * 方式二：变量 f 的数据类型改为 double ： double f = 3.4;
   * 方式三：使用造型符号，强类型转换： float f = (float)3.4;