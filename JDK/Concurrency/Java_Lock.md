# Java锁详解

原文：https://www.toutiao.com/article/7116916831637684748/



### 1. 公平锁 vs 非公平锁

* **公平锁**：

  是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。类似于排队打饭，先来先得。

  

* **非公平锁**：

  是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获得锁。

#### 比较

公平锁，就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果是空，或者当前线程是等待队列的第一个，就占有锁；否则就会加入到等到队列中，以后按照FIFO的原则从队列中获取到自己。

非公平锁，比较粗鲁，上来就直接尝试占有锁。如果尝试失败，就再采取类似公平锁的方式。

公平锁的优点是等待锁的线程不会饿死。

非公平锁的优点在于吞吐量比公平锁大。但在高并发的情况下，有可能会造成**优先级反转**或者**饥饿现象**。



#### 内窥

并发包中 **ReentrantLock** 的创建可以指定构造函数的 boolean 类型来得到公平锁或者非公平锁，默认是非公平锁。

查看 ReentrantLock，可以看到有一个继承自 AbstractQueuedSynchronizer的内部类 Sync，添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。它有公平锁 FairSync 和非公平所 NonfairSync 两个子类。

```java
public class ReentrantLock implements Lock, java.io.Serializable {
    private static final long serialVersionUID = 7373984872572414699L;
    private final Sync sync;
    
    public ReentrantLock() {
        sync = new NonfairSync();
    }
    
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
    
    abstract static class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = -5179523762034025860L;

        abstract void lock();
		//......
    }
  
    static final class NonfairSync extends Sync {
		//......
    }

    static final class FairSync extends Sync {
        //......
    }   
}
```

两个构造方法对比，可以看出公平锁和非公平所的区别：

* 非公平锁在调用 ***lock()*** 后，首先就会通过 CAS 进行一次抢锁。如果这个时候恰巧锁没有被占用，那么就直接获取到锁返回；否则就按公平锁的方式去排队，进入到阻塞队列等待唤醒。
* 公平锁在获取同步状态（获取锁）时 ***tryAcquire()*** 多了一个限制条件： *!hasQueuePredecessors()*，用来判断当前线程是否位于同步队列中的第一个

**Synchronized 关键字也是一种非公平锁。**



### 2. 乐观锁 vs 悲观锁

乐观锁和悲观锁是一种广义上呃概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。

* 悲观锁是一种悲观思想，它总认为自己在使用数据的时候一定有别的线程来修改。所以悲观锁在持有数据的时候总会把资源或者数据锁住，这样其他线程想要请求这个资源的时候就会阻塞，直到等到悲观锁把资源释放为止。传统的关系型数据库里边就用到了很多锁机制，比如行锁、表锁等，读锁、写锁等，都是在做操作之前先上锁。悲观锁的实现往往依靠数据库本身的所功能实现。
* Java 中 Synchronized 关键字和 Lock 的实现类都是悲观锁
* 乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入；如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）
* 乐观锁的实现方案一般来说有两种：**版本号机制**  和 **CAS实现**。
* Java 中 java.util.concurrent.atomic 包下面的原子变量类的递增操作就是通过 CAS 实现了乐观锁

#### 比较

* **悲观锁**

  比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量

* **乐观锁**

  比较适合读取操作比较频繁的场景。如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断地重新获取数据，这样会增加大量地查询操作，降低了系统地吞吐量

**悲观锁比较适合强一致性场景，但效率比较低，特别是读的并发低；乐观锁适用于读多写少，并发冲突少的场景。**

乐观锁常见的问题：

* ABA问题
* 循环时间长、开销大
* 只能保证一个共享变量的原子操作



### 3. 可重入锁（递归锁）

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提：锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。

也就是说，**线程可以进入任何一个它已经拥有的锁同步着的代码块**。

**可重入锁的最大的作用是可以一定程度避免死锁**，ReentrantLock、Synchonized 就是典型的可重入锁。

```java
public class Wget {
    public synchronized void doSomething() {
        System.out.println("方法1执行...");
        doOthers();
	}
    public synchronized void doOthers() {
        System.out.println("方法2执行...");
    }
}
```

在上面代码中，类中的两个方法都是被内置锁 synchronized 修饰的，doSomething() 方法中调用 doOthers() 方法。因为内置锁是可重入的，所以同一个线程在调用 doOthers() 时可以直接获得当前对象的锁，进入 doOthers() 进行操作。

如果是一个不可重入锁，那么当前线程在调用 doOthers() 之前需要将执行 doSomething() 时获取当前对象的锁释放掉，实际上该对象锁已经被当前线程所持有，且无法释放。所以会出现死锁。



#### 自旋锁

自选锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少上下文切换的消耗，缺点是循环会消耗CPU。

``` java
public class SpinLockDemo {
    AtomicReference<Thread> lock = new AtomicReference<>();

    public void myLock(){
        Thread thread = Thread.currentThread();
        //如果不为空，自旋
        while (!lock.compareAndSet(null,thread)){

        }
    }

    public void myUnlock(){
        Thread thread = Thread.currentThread();
        //解锁后，将锁置为 null
        lock.compareAndSet(thread,null);
    }
}
```



#### 优缺点

* 优点
  1. 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是 active；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快
  2. 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态。当获取到锁的时候需要从内核态恢复，需要线程上下文切换。（线程被阻塞后便进入内核调度状态，这个会导致系统在用户态和内核态之间来回切换，严重影响锁的性能）
* 缺点
  1. 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高
  2. 上面 Java 实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。



#### 可重入的自旋锁和不可重入的自旋锁

上边写的自旋锁，仔细分析一下可以看出，它是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入 while 循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。

而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。

为了实现可重入锁，需要引入一个计数器，用来记录获取锁的线程数。



#### 自旋锁与互斥锁

* 自旋锁与互斥锁都是为了实现保护资源共享的机制
* 无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者
* 获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放



#### 总结

* 自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁
* 自旋锁等待期间，线程的状态不会改变，线程一直使用户态并且是活动的（active）
* 自旋锁如果持有锁的时间太长，则会导致其他等待获取锁的线程耗尽CPU
* 自旋锁本身无法保证公平，同时也无法保证可重入性
* 基于自旋锁，可以实现具备公平性和可重入性质的锁



### 4. 独占锁（互斥锁/写锁）、共享锁（读锁）

* **独占锁**

  指该锁一次只能被一个线程所持有，对 ReentrantLock 和 Synchronized 而言都是独占锁

* **共享锁**

  指该锁可被多个线程持有

对 ReentrantReadWriteLock 其读锁是共享锁，写锁是独占锁。

读锁的共享锁可保证并发读是非常高效的，读写、写读、写写的过程是互斥的。



#### 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁

这四种锁是指锁的状态，专门针对 synchronzed 的。在介绍这四种锁状态之前，还需要介绍一些额外的知识。

首先，为什么 Sychronized 能实现线程同步？

回答这个问题前需要了解两个重要的概念： Java 对象头、Monitor



#### 无锁

无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。

无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。



#### 偏向锁

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。

在大多数情况下，锁总是由同一个线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。

当一个线程访问同步代码块并获取锁时，**会在 Mark Word 里存储锁偏向的线程ID**。在线程进入和退出同步代码块时不再通过CAS操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。

偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节吗正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁状态。撤销偏向锁后恢复到无所（标志位为 01）或轻量级锁（标志位为 00）的状态。

偏向锁在 JDK 6 及以后的JVM里默认开启，可以通过JVM参数关闭偏向锁： -XX:-UsedBiasedLocking=false， 关闭后程序默认会进入轻量级锁状态。



#### 轻量级锁

当锁是偏向锁的时候，被另外的线程锁访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。

在代码进入同步块的时候，如果同步对象锁状态为无所状态（锁标志位为 01 状态，是否为偏向锁为 “0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后拷贝对象头中的 Mark Word 复制到锁记录中。

拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将Lock Record 里的 owner 指针指向对象的 Mark Word。

如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。

如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。

若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。



#### 重量级锁

升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。



#### 总结

综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。