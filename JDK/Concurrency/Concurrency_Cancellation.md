# 任务取消

原文：http://ifeve.com/cancellation/



​        当某个线程中的活动执行失败或想改变运行意图，也许就有必要或想要在其它线程中取消这个线程的活动，而不管这个线程正在做什么。取消会给运行中的线程带来一些无法预料的失败情况。取消操作异步特性相关的设计技巧，让人想起了因系统崩溃和连接断开任何时候都有可能失败的分布式系统的那些技巧。并发程序还要确保多线程共享的对象的状态一致性。

​        在大多数多线程程序中，取消任务（Cancellation）是普遍存在的，常见于：

* 几乎所有与GUI中取消按钮相关的活动
* 多媒体演示（如动画循环）中的正常终止活动
* 线程中生成的结果不再需要。例如使用多个线程搜索数据库，只要某个线程返回了结果，其他的线程都可以取消
* 由于一组活动中的一个或多个遇到意外错误或异常导致整租活动无法继续



## 中断 (Interruption)

​        实现取消任务的最佳技术是使用线程的中断状态，这个状态由Thread.interrupt设置，可被Thread.isInterrupted检测到，通过Thread.interrupted清除，有时候抛出InterruptedException异常来响应。

​        **线程中断起着请求取消活动的作用**。但无法阻止有人将其用作它途，而用来作取消操作是预期的用途。基于中断的任务取消依赖于取消者和被取消者间的一个协议以确保跨多线程使用的对象在被取消线程终止的时候不被损坏。大部分（理想情况下是所有的）java.*包中的类都遵守这个协议。

​        几乎在所有的情况下，取消一个与线程有关系的活动都应当终止对应的线程。但中断机制不会强制线程立马终止。这就给任何被中断的线程一个在终止前做些清理操作的机会，但也给代码增加了及时检查中断状态以及采取合适操作的职责。

​        延迟甚至忽略任务取消的请求给写出良好响应性且非常健壮的代码提供了途径。因为不会直接将线程中断掉，所以很难或不可能撤销的动作的前面可以作为一个安全点，然后在此安全点检查中断状态。响应中断大部分可选的方式在$3.1.1中有讨论。

​        继续执行（忽略或者清除了中断）可能适用于那些不打算终止的线程。例如，那些对于程序基本功能不肯或缺的数据库管理服务。一旦遇到中断，可中止这些特殊任务，然后允许线程继续执行其他任务。然而，即使在这里，将中断的线程替换成一个处于初始状态的新启动的线程会更易于管理。

​        突然终止（比如抛出错误）一般适用于提供独立服务、除了run方法中finally子句外无需其它清理操作的线程。但是，当线程执行的服务被其他线程依赖时（见$4.3），就应当以某种形式通知这些依赖的线程或设置状态指示。（异常本身不会自动在线程间传播）

​        线程中使用的对象被其它线程依赖时必须使用回滚或前滚技术。

​        在某种程度上，可通过决定多久用Thread.currentThread().isInterrupted()来检查中断状态以控制代码对中断的响应灵敏性。中断状态检查不需要太频繁以免影响程序效率。例如，如果需要取消的活动包含大约10000条指令，每10000条指令做一次取消检查，那么从取消请求到关闭平均会消耗15000条指令。只要活动继续运行没有什么实际的危害，这个数量级可以满足大部分应用的需求。通常，这个理由可以让你将中断检测代码仅放到既方便检测又是重要的程序点。在性能关键型应用中，也许值得构建一个分析模型或收集经验值来准确地决定响应性与吞吐量间的最佳权衡。

​        Object.wait()，Thread.join()，Thread.sleep()以及他们衍生出的方法都会自动检测中断。这些方法一旦中断就会抛出InterruptedException来中止，然后让线程苏醒并执行与活动取消相关的代码。

​        按照惯例，应当在抛出InterruptedException时清除中断状态。有时候有必要这样做来支持一些清理工作，但这也可能是错误与混乱之源。当处理完InterruptedException后想要传播中断状态，必须要么重新抛出捕获的InterruptedException，要么通过Thread.currentThread().interrupt()重新设置中断状态。如果你的代码调用了其它未正确维持中断状态的代码（例如，忽略InterruptedException又不重设状态），可以能通过维持一个字段来规避问题，这个字段用于保存活动取消的标识，在调用interrupte的时候设置该字段，从有问题的调用中返回时检查该字段。

​        有两种情况线程会保持休眠而无法检测中断状态或接收InterruptedException：在同步块中和在I/O中阻塞时。线程在等待同步方法或者同步块的锁时不会对中断有响应。但是，如$2.5中讨论的，当需要大幅降低在活动取消间被卡在锁等待中的几率，可以使用lock工具类。使用lock类的代码阻塞仅是为了访问锁对象本身，而不是这些锁所保护的代码。这些阻塞的耗时天生就很短（尽管时间不能严格保证）。