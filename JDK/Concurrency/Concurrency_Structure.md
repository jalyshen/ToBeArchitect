# Java并发结构

原文：http://ifeve.com/java-concurrency-constructs/

## 线程

​        线程是一个独立执行的调用序列，同一个进程的线程在同一时刻共享一些系统资源（比如文件句柄等），也能访问同一个进程所创建的对象资源（如内存资源）。

​        java.lang.Thread对象负责统计和控制这种行为。

​        每个程序都至少拥有一个线程-即作为Java虚拟机启动参数运行在主类main方法的线程。在JVM初始化过程中，也可能启动其他的后台线程。这种线程的数目和种类，因JVM的实现而异。然而，所有用户级线程，都是显式被构造并在主线程或者其他用户线程中被启动。

​        这里对Thread类中的主要方法和属性，以及一些使用注意事项作出总结。这些内容在书《Java Concurrency Constructs》上进行进一步的探讨阐述。



### 构造方法

​        Thread类中不同的构造方法接受如下参数的不同组合：

* 一个Runnable对象：这种情况，Thread.start方法将会调用对应Runnable对象的run方法。如果没有提供Runnable对象，那么就会立即得到一个Thread.run的默认实现
* 一个作为线程标识名的String字符串：该标识在跟踪和调试过程中会非常有用，除此别无他用
* 线程组(ThreadGroup)：用来放置新创建的线程，如果提供的ThreadGroup不允许被访问，那么就会抛出一个SecurityException

​        Thread类本身就已经实现了Runnable接口，因此，除了提供一个用于执行的Runnable对象作为构造参数的办法之外，也可以创建一个Thread的子类，通过重写其run方法来达到同样的效果。然而，**比较好的实践方式确实分开定一个Runnable对象并用来作为构造方法的参数。**将代码分散在不同的类中，使得开发人员不需纠结于Runnable和Thread对象中使用的同步方法或同步块之间的内部交互。更普遍的是，这种分隔使得对操作的本身与其运行的上下文有着独立的控制。更好的是，同一个Runnable对象可以同时用来初始化其他的线程，也可以用于构造一些轻量化的执行框架（Executors）。另外需要提到的是通过继承Thread类实现线程的方式有一个缺点：使得该类无法再继承其他的类。

​        Thread对象拥有一个守护（Daemon）标识属性，这个属性无法在构造方法中被赋值，但是可以在线程启动之前设置该属性（通过setDaemon方法）。当程序中所有的非守护线程都已经终止，调用setDaemon方法可能会导致虚拟机粗暴的终止线程并退出。isDaemon方法能够返回该属性的值。守护状态的作用非常有限，即使是后台线程在程序退出的时候也经常需要做一些清理工作。



### 启动线程

​        调用start方法会触发Thread实例以一个新的线程启动其run方法。新线程不会持有调用线程的任何同步锁。

​        当一个线程正常地运行结束，或者抛出某种未检测的异常（比如：运行时异常RunningException、错误ERROR或者其子类），线程就会终止。当线程终止之后，是不能被重新启动的。在同一个Thread上调用多次start方法会抛出InvalidThreadStateException异常。

​        如果线程已经启动但是还没有终止，那么调用isAlive方法就会返回true，即使线程由于某些原因处于阻塞（Blocked）状态，该方法依然返回True。如果线程已经被取消（cancelled），那么该方法在什么时候返回false，就因各JVM的实现差异了。没有方法可以得知一个处于非活跃状态的线程是否已经被启动过（即：线程在开始运行前和结束运行后都会被返回false，无法得知处于false的线程具体的状态）。另外，虽然一个线程能够得知同一个线程组的其他线程的标识，但是却无法得知自己是由哪个线程调用启动的。



### 优先级

​         JVM为了实现跨平台的特性，Java语言在线程调用与调度公平性上未作出任何的承诺，甚至都不会严格保证线程会被执行。但是Java线程却支持优先级的方法，这些方法会影响线程的调度。

​        每个线程都有一个优先级，分布在Thread.MIN_PRIORITY和Thread.MAX_PRIORITY之间（分别是1和10）。默认情况下，新创建的线程都拥有和创建它的线程相同的优先级。main方法所关联的初始化线程拥有一个默认的优先级，这个优先级是Thread.NORM_PRIORITY(5)。 可以通过getPriority方法获得线程的优先级，也可以通过setPriority方法来动态修改。**一个线程的最高优先级有其所在的线程组限定**。



## 同步

## 监视器